from aiohttp import web
import aiohttp_jinja2
import jinja2
import asyncpg
from asyncpg.exceptions import DuplicateTableError
import re
import time

FIELDS = {'entity_email', 'check', 'bio', 'superpowers', 'gender-group', 'entity_birth', 'entity_name', 'limbs'}

YEAR = 365 * 24 * 60 * 60

create_query = 'CREATE TABLE forms (' \
               'id bigint PRIMARY KEY GENERATED BY DEFAULT AS IDENTITY,' \
               'name VARCHAR(256),' \
               'email VARCHAR(256),' \
               'year INTEGER,' \
               'gender VARCHAR(256),' \
               'limbs VARCHAR(256),' \
               'superpowers TEXT[],' \
               'biography TEXT)'

insert_query = 'INSERT INTO forms (name, email, year, gender, limbs, superpowers, biography) VALUES (($1), ($2), ' \
               '($3), ($4), ($5), ($6), ($7))'


app = web.Application()
aiohttp_jinja2.setup(app, loader=jinja2.FileSystemLoader('./templates'))


async def create_table():
    con = await asyncpg.connect(user='kmx', database='back')
    try:
        await con.execute(create_query)
    except DuplicateTableError:
        print("Table forms already exists")
    await con.close()


async def insert(data):
    con = await asyncpg.connect(user='kmx', database='back')
    await con.execute(insert_query, data['entity_name'], data['entity_email'], int(data['entity_birth']),
                     data['gender-group'], data['limbs'], data.getall('superpowers'), data['bio'])
    await con.close()


async def index(request):
    print(request.cookies)
    errors = request.cookies['errors'] if 'errors' in request.cookies else ""
    incor = request.cookies['incor_fields'] if 'incor_fields' in request.cookies else ""
    context = {'cookies': request.cookies, 'errors': errors, 'incor': incor}
    response = aiohttp_jinja2.render_template('index.jinja2', request, context)
    return response


async def form(request):
    data = await request.post()
    keys_set = {k for k in data}
    response = web.HTTPSeeOther('/task3')
    errors = []
    incorrect_fields = []
    if len(FIELDS - keys_set) > 0:
        errors.extend(FIELDS - keys_set)
    elif len(keys_set - FIELDS) > 0:
        errors.append('too many fields')
    empties = list(filter(lambda x: data[x] is '', ('entity_name', 'entity_email', 'bio')))

    if len(empties) > 0:
        errors.extend(empties)

    if re.match(r'^[a-zA-Zа-яА-Я ]+$', data['entity_name']) is None and 'entity_name' not in empties:
        errors.append('entity_name')
        incorrect_fields.append('entity_name')
    if re.match(r'^[\w._]+@[a-z]+\.[a-z]+$', data['entity_email']) is None and 'entity_email' not in empties:
        errors.append('entity_email')
        incorrect_fields.append('entity_email')

    response.set_cookie('errors', str(errors), max_age=1)
    response.set_cookie('incor_fields', str(incorrect_fields), max_age=1)

    response.set_cookie('entity_name', data['entity_name'], max_age=YEAR)
    response.set_cookie('entity_email', data['entity_email'], max_age=YEAR)

    if len(errors) > 0:
        response.set_cookie('saved', 'False', max_age=1)
    else:
        await insert(data)
        response.set_cookie('saved', 'True', max_age=YEAR)
    return response


async def entrance():
    await create_table()
    app.add_routes([
        web.get(r'/task3/', index),
        web.post('/task3/', form)
    ])
    return app

if __name__ == '__main__':
    web.run_app(entrance())
